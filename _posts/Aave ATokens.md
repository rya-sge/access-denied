# Aave V3 Origin -  ATokens

`aTokens` are tokens minted and burnt upon supply and withdraw of assets to an Aave market. 

- aTokens denote the amount of crypto assets supplied to the protocol and the yield earned on those assets. 
- The aTokensâ€™ value is pegged to the value of the corresponding supplied asset at a 1:1 ratio and can be safely stored, transferred or traded. 
- All yield collected by the aTokens' reserves are distributed to aToken holders directly by continuously increasing their wallet balance.

This contract is the implementation of the interest bearing token for the Aave Protocol. 



https://github.com/aave/aave-v3-horizon/blob/main/src/contracts/protocol/tokenization/AToken.sol

[TOC]



### Details

- It inherits the [ScaledBalanceTokenBase](https://github.com/aave-dao/aave-v3-origin/blob/main/src/contracts/protocol/tokenization/base/ScaledBalanceTokenBase.sol) and [EIP712Base](https://github.com/aave-dao/aave-v3-origin/blob/main/src/contracts/protocol/tokenization/base/EIP712Base.sol) token contracts.
- All standard EIP20 methods are implemented for aTokens, such as balanceOf, transfer, transferFrom, approve, totalSupply etc.
- `balanceOf`will always return the most up to date balance of the user, which includes their principal balance and the yield generated by the principal balance.

The source code is available on [GitHub](https://github.com/aave-dao/aave-v3-origin/blob/main/src/contracts/protocol/tokenization/AToken.sol).

### Purpose

- **ATokens** represent a userâ€™s deposit in Aave.
- Their balance grows over time automatically as interest accrues (without explicitly minting new tokens to each user).
- This growth is implemented through *scaled balances* multiplied by an index from the lending pool.

------

### Architecture

The contract inherits from:

- **`VersionedInitializable`** â€“ allows upgradeable deployment with a fixed version number (`ATOKEN_REVISION` = `0x1`).
- **`ScaledBalanceTokenBase`** â€“ stores balances in a scaled format, where the *actual* balance is `scaledBalance * index`.
- **`EIP712Base`** â€“ supports EIP-2612 style `permit()` approvals.
- **`IncentivizedERC20`** â€“ integrates with the Aave incentive system for rewards.
- **`IAToken`** â€“ standard interface for all ATokens.

It also uses:

- **`WadRayMath`** â€“ fixed-point math with 27 decimals (ray precision).
- **`GPv2SafeERC20`** â€“ safe token transfer library from Gnosis.
- **`SafeCast`** â€“ safe uint conversions.

------

### Key State Variables

- `_treasury` â€“ address where protocol fee revenue is sent.
- `_underlyingAsset` â€“ the ERC20 that the AToken represents (e.g., DAI, USDC).
- `POOL` (inherited) â€“ the main lending pool contract that is the only one allowed to mint/burn.

------

### Interest Accrual Mechanism

Instead of incrementing balances for everyone when interest accrues:

- Balances are stored in a scaled form.
- When queried, they are multiplied by the **normalized income index** from the Pool.
- This means balances "magically" increase over time without per-user writes.

------

### Access Control

- **`onlyPool`** â€“ ensures that only the Pool can mint, burn, or move ATokens for protocol operations.
- **`onlyPoolAdmin`** â€“ allows administrative token rescue.
- This protects against arbitrary minting/burning from external actors.

------

### Upgradeability

- Relies on **`VersionedInitializable`** to avoid reinitialization issues.
- Constructor is mostly empty; real initialization happens via `initialize()`.

------

### Potential Risks & Security Considerations

- **Underlying asset rescue prevention** â€“ ensures the Pool Admin cannot rug the deposits.
- **Index manipulation** â€“ relies entirely on the Pool to supply a correct `getReserveNormalizedIncome()` value.
- **Permit signature replay** â€“ handled with nonces in `permit()`.
- **Safe transfers** â€“ uses GPv2SafeERC20 to avoid ERC20 non-compliance issues.
- **Upgradeable** â€“ requires careful governance to ensure upgrade logic isnâ€™t malicious.
- **Validation flag in `_transfer`** â€“ certain transfers bypass health factor checks (like liquidation transfers), which is intended but must be controlled.

------

### Bottom Line

This contract is:

- An **interest-bearing, upgradeable ERC20** tightly coupled with the Aave lending pool.
- Uses **scaled balances + index math** for efficient interest accrual.
- Designed with **strict access control** to prevent unauthorized mint/burn.
- Integrates **permit**, **treasury minting**, and **liquidation transfer** mechanics.
- **Risks** mainly lie in the Pool contract integrity and upgrade governance.

## Key Differences: Original Aave vs. Aave Horizon

The **Horizon** version you provided earlier is essentially a **modified fork** of this original, with some simplifications and internal changes:

| Feature                            | Original Aave                                                | Aave Horizon                                                 |
| ---------------------------------- | ------------------------------------------------------------ | ------------------------------------------------------------ |
| **Math library**                   | Uses `TokenMath` helpers for all scaled/unscaled conversions. | Uses `WadRayMath` directly for ray math.                     |
| **Treasury handling**              | Immutable `TREASURY` set in constructor.                     | Mutable `_treasury` set in `initialize()`.                   |
| **Mint/Burn params**               | Requires both `scaledAmount` and `amount` in function params (caller computes scaling). | Takes raw `amount` and `index`, then computes scaling inside `_mintScaled` / `_burnScaled`. |
| **Transfer logic**                 | Tracks per-user interest accrual via `_userState.additionalData` and emits `Mint` events to represent interest. | No per-user interest tracking; uses simpler `POOL.finalizeTransfer` validation without extra mint events. |
| **Permit**                         | Uses `ECDSA.recover` from OpenZeppelin.                      | Uses raw `ecrecover` call.                                   |
| **transferFrom rounding handling** | Has complex logic to adjust allowance consumption for scaled balances. | No special `transferFrom` overrideâ€”relies on base ERC20 allowance logic. |
| **Abstract contract**              | `AToken` is abstract, requiring `initialize()` implementation. | Fully implemented contract with working `initialize()`.      |
| **State compatibility**            | Has `_deprecated_treasury` for storage layout continuity.    | No deprecated fields.                                        |
| **Event emission**                 | Emits synthetic mint events for interest accrual.            | Does not emit such interest-minting eventsâ€”simpler logs.     |

### handleRepayment

- **Original Aave**:

  - **No `handleRepayment` function**.

- **Aave Horizon**:

  ```solidity
  function handleRepayment(address user, address onBehalfOf, uint256 amount)
  ```

  - Present, but intentionally empty.

**Difference** â†’ Exists only in Horizon.

### Difference between Aave protocol v1.0

Got it â€” so hereâ€™s the **3-column function presence comparison** between **Aave v1.0**, **Aave Atoken Origin (v3)**, and **Aave Horizon** based on the code weâ€™ve reviewed.

| Function Name                       | v1.0 (Old)            | Atoken Origin (v3)                | Horizon                         |
| ----------------------------------- | --------------------- | --------------------------------- | ------------------------------- |
| `initialize`                        | âœ…                     | âœ…                                 | âœ…                               |
| `mint`                              | âœ…                     | âœ…                                 | âœ…                               |
| `burn`                              | âœ…                     | âœ…                                 | âœ…                               |
| `mintToTreasury`                    | âŒ                     | âœ…                                 | âœ…                               |
| `transferOnLiquidation`             | âœ…                     | âœ…                                 | âœ…                               |
| `balanceOf`                         | âœ… (simple)            | âœ… (scaled w/ index)               | âœ… (scaled w/ index)             |
| `totalSupply`                       | âœ… (simple)            | âœ… (scaled w/ index)               | âœ… (scaled w/ index)             |
| `RESERVE_TREASURY_ADDRESS`          | âŒ                     | âœ…                                 | âœ…                               |
| `UNDERLYING_ASSET_ADDRESS`          | âœ…                     | âœ…                                 | âœ…                               |
| `transferUnderlyingTo`              | âœ…                     | âœ…                                 | âœ…                               |
| `permit`                            | âŒ                     | âœ…                                 | âœ…                               |
| `transferFrom`                      | âœ… (basic ERC20 logic) | âœ… (scaled balance & rounding fix) | âœ… (scaled balance, similar fix) |
| `_transfer` (overridden)            | âœ… (simple)            | âœ… (scaled + finalizeTransfer)     | âœ… (scaled + finalizeTransfer)   |
| `_transfer` (internal scaled logic) | âŒ                     | âœ…                                 | âœ…                               |
| `DOMAIN_SEPARATOR`                  | âŒ                     | âœ…                                 | âœ…                               |
| `nonces`                            | âŒ                     | âœ…                                 | âœ…                               |
| `_EIP712BaseId`                     | âŒ                     | âœ…                                 | âœ…                               |
| `rescueTokens`                      | âŒ                     | âœ…                                 | âœ…                               |



### Key Observations:

- **v1.0 was minimal** â€” no EIP-712 permit, no mint-to-treasury, no domain separator, no explicit rescue function.
- **Atoken Origin (v3)** introduced:
  - Permit / EIP-712
  - Mint-to-treasury
  - Scaled balance rounding-safe transfer logic
  - Explicit `RESERVE_TREASURY_ADDRESS`
  - `rescueTokens`
- **Horizon** kept most v3 functions but:
  - Adjusted internal logic for gas efficiency
  - Tweaked rounding and scaled amount handling
  - Maintained EIP-712 features

## Surya report

### Contracts Description Table


|  Contract  |                        Type                         |        Bases         |                |                     |
| :--------: | :-------------------------------------------------: | :------------------: | :------------: | :-----------------: |
|     â””      |                  **Function Name**                  |    **Visibility**    | **Mutability** |    **Modifiers**    |
|            |                                                     |                      |                |                     |
| **AToken** |                   Implementation                    | ERC20, ERC20Detailed |                |                     |
|     â””      |                    <Constructor>                    |       Public â—ï¸       |       ğŸ›‘        |    ERC20Detailed    |
|     â””      |                      _transfer                      |      Internal ğŸ”’      |       ğŸ›‘        | whenTransferAllowed |
|     â””      |               redirectInterestStream                |      External â—ï¸      |       ğŸ›‘        |         NOâ—ï¸         |
|     â””      |              redirectInterestStreamOf               |      External â—ï¸      |       ğŸ›‘        |         NOâ—ï¸         |
|     â””      |             allowInterestRedirectionTo              |      External â—ï¸      |       ğŸ›‘        |         NOâ—ï¸         |
|     â””      |                       redeem                        |      External â—ï¸      |       ğŸ›‘        |         NOâ—ï¸         |
|     â””      |                    mintOnDeposit                    |      External â—ï¸      |       ğŸ›‘        |   onlyLendingPool   |
|     â””      |                  burnOnLiquidation                  |      External â—ï¸      |       ğŸ›‘        |   onlyLendingPool   |
|     â””      |                transferOnLiquidation                |      External â—ï¸      |       ğŸ›‘        |   onlyLendingPool   |
|     â””      |                      balanceOf                      |       Public â—ï¸       |                |         NOâ—ï¸         |
|     â””      |                 principalBalanceOf                  |      External â—ï¸      |                |         NOâ—ï¸         |
|     â””      |                     totalSupply                     |       Public â—ï¸       |                |         NOâ—ï¸         |
|     â””      |                  isTransferAllowed                  |       Public â—ï¸       |                |         NOâ—ï¸         |
|     â””      |                    getUserIndex                     |      External â—ï¸      |                |         NOâ—ï¸         |
|     â””      |            getInterestRedirectionAddress            |      External â—ï¸      |                |         NOâ—ï¸         |
|     â””      |                getRedirectedBalance                 |      External â—ï¸      |                |         NOâ—ï¸         |
|     â””      |               cumulateBalanceInternal               |      Internal ğŸ”’      |       ğŸ›‘        |                     |
|     â””      | updateRedirectedBalanceOfRedirectionAddressInternal |      Internal ğŸ”’      |       ğŸ›‘        |                     |
|     â””      |          calculateCumulatedBalanceInternal          |      Internal ğŸ”’      |                |                     |
|     â””      |               executeTransferInternal               |      Internal ğŸ”’      |       ğŸ›‘        |                     |
|     â””      |           redirectInterestStreamInternal            |      Internal ğŸ”’      |       ğŸ›‘        |                     |
|     â””      |           resetDataOnZeroBalanceInternal            |      Internal ğŸ”’      |       ğŸ›‘        |                     |


### Legend

| Symbol | Meaning                   |
| :----: | ------------------------- |
|   ğŸ›‘    | Function can modify state |
|   ğŸ’µ    | Function is payable       |

## Write Methods

### initialize

```solidity
function initialize(    IPool initializingPool,    address treasury,    address underlyingAsset,    IAaveIncentivesController incentivesController,    uint8 aTokenDecimals,    string calldata aTokenName,    string calldata aTokenSymbol,    bytes calldata params) public virtual
```

Called when aToken instance is initialized.

#### Code

```solidity
  /// @inheritdoc IInitializableAToken
 function initialize(
    IPool initializingPool,
    address underlyingAsset,
    uint8 aTokenDecimals,
    string calldata aTokenName,
    string calldata aTokenSymbol,
    bytes calldata params
  ) public virtual;
```



#### Input Parameters:

| Name                 | Type                      | Description                                               |      |
| -------------------- | ------------------------- | --------------------------------------------------------- | ---- |
| initializingPool     | IPool                     | The address of the associated pool                        |      |
| treasury             | address                   | The address of the treasury                               |      |
| underlyingAsset      | address                   | The address of the underlying asset                       |      |
| incentivesController | IAaveIncentivesController | The address of the incentives controller for this aToken  |      |
| aTokenDecimals       | uint8                     | The decimals of the underlying asset                      |      |
| aTokenName           | string                    | The name of the aToken                                    |      |
| aTokenSymbol         | string                    | The symbol of the aToken                                  |      |
| params               | bytes                     | A set of encoded parameters for additional initialization |      |

### mint

```solidity
function mint(    address caller,    address onBehalfOf,    uint256 amount,    uint256 index) external virtual override onlyPool returns (bool)
```

Mints amount aTokens to user.

#### Code

```solidity
  /// @inheritdoc IAToken
  function mint(
    address caller,
    address onBehalfOf,
    uint256 scaledAmount,
    uint256 index
  ) external virtual override onlyPool returns (bool) {
    return
      _mintScaled({
        caller: caller,
        onBehalfOf: onBehalfOf,
        amountScaled: scaledAmount,
        index: index,
        getTokenBalance: TokenMath.getATokenBalance
      });
  }
```

#### Input Parameters:

| Name       | Type    | Description                                                  |      |
| ---------- | ------- | ------------------------------------------------------------ | ---- |
| caller     | address | The address performing the mint                              |      |
| onBehalfOf | address | The address of the user that will receive the minted aTokens |      |
| amount     | uint256 | The amount of tokens getting minted                          |      |
| index      | uint256 | The next liquidity index of the reserve                      |      |

#### Return Values:

| Type | Description                                        |      |
| ---- | -------------------------------------------------- | ---- |
| bool | true if the the previous balance of the user was 0 |      |

### burn

```solidity
function burn(address from, address receiverOfUnderlying, uint256 amount, uint256 index) external virtual override onlyPool
```

Burns aTokens from user and sends the equivalent amount of underlying to receiverOfUnderlying.

In some instances, the mint event could be emitted from a burn transaction if the amount to burn is less than the interest that the user accrued.

#### Code

```solidity
  /// @inheritdoc IAToken
  function burn(
    address from,
    address receiverOfUnderlying,
    uint256 amount,
    uint256 scaledAmount,
    uint256 index
  ) external virtual override onlyPool returns (bool) {
    bool zeroBalanceAfterBurn = _burnScaled({
      user: from,
      target: receiverOfUnderlying,
      amountScaled: scaledAmount,
      index: index,
      getTokenBalance: TokenMath.getATokenBalance
    });

    if (receiverOfUnderlying != address(this)) {
      IERC20(_underlyingAsset).safeTransfer(receiverOfUnderlying, amount);
    }
    return zeroBalanceAfterBurn;
  }
```



#### Input Parameters:

| Name                 | Type    | Description                                        |      |
| -------------------- | ------- | -------------------------------------------------- | ---- |
| from                 | address | The address from which the aTokens will be burned  |      |
| receiverOfUnderlying | address | The address that will receive the underlying asset |      |
| amount               | uint256 | The amount of tokens that will be burned           |      |
| index                | uint256 | The next liquidity index of the reserve            |      |

### mintToTreasury

```solidity
function mintToTreasury(uint256 amount, uint256 index) external override onlyPool
```

Mints aTokens to the reserve treasury.

#### Code

```solidity
  /// @inheritdoc IAToken
  function mintToTreasury(uint256 scaledAmount, uint256 index) external virtual override onlyPool {
    if (scaledAmount == 0) {
      return;
    }
    _mintScaled({
      caller: address(POOL),
      onBehalfOf: TREASURY,
      amountScaled: scaledAmount,
      index: index,
      getTokenBalance: TokenMath.getATokenBalance
    });
  }
```



#### Input Parameters:

| Name   | Type    | Description                                        |      |
| ------ | ------- | -------------------------------------------------- | ---- |
| amount | uint256 | The amount of tokens getting minted                |      |
| index  | uint256 | The address that will receive the underlying asset |      |

### transferOnLiquidation

```solidity
function transferOnLiquidation(    address from,    address to,    uint256 value) virtual override onlyPool
```

Transfers aTokens in the event of a borrow being liquidated, in case the liquidator reclaims the aToken.

#### Code

```solidity
  /// @inheritdoc IAToken
  function transferOnLiquidation(
    address from,
    address to,
    uint256 amount,
    uint256 scaledAmount,
    uint256 index
  ) external virtual override onlyPool {
    _transfer({
      sender: from,
      recipient: to,
      amount: amount,
      scaledAmount: scaledAmount.toUint120(),
      index: index
    });
  }

```

#### Input Parameters:

| Name  | Type    | Description                                                  |      |
| ----- | ------- | ------------------------------------------------------------ | ---- |
| from  | address | The address getting liquidated, current owner of the aTokens |      |
| to    | address | The recipient of aTokens                                     |      |
| value | uint256 | The amount of tokens getting transferred                     |      |

### transferUnderlyingTo

```solidity
function transferUnderlyingTo(address target, uint256 amount) external virtual override onlyPool
```

Transfers the underlying asset to target.

Used by the [Pool](https://aave.com/docs/developers/smart-contracts/pool) to transfer assets in borrow(), withdraw() and flashLoan().

#### Code

```solidity
/// @inheritdoc IAToken
  function transferUnderlyingTo(address target, uint256 amount) external virtual override onlyPool {
    IERC20(_underlyingAsset).safeTransfer(target, amount);
  }

```

#### Input Parameters:

| Name   | Type    | Description                     |      |
| ------ | ------- | ------------------------------- | ---- |
| user   | address | The recipient of the underlying |      |
| amount | uint256 | The amount getting transferred  |      |

### handleRepayment

```solidity
function handleRepayment(address user, address onBehalfOf, uint256 amount) external virtual override onlyPool
```

Handles the underlying received by the aToken after the transfer has been completed.

The default implementation is empty as with standard ERC20 tokens, nothing needs to be done after the transfer is concluded. However in the future there may be aTokens that allow for example to stake the underlying to receive LM rewards. In that case, handleRepayment() would perform the staking of the underlying asset.

#### Input Parameters:

| Name       | Type     | Description                                         |      |
| ---------- | -------- | --------------------------------------------------- | ---- |
| user       | address  | The user executing the repayment                    |      |
| onBehalfOf | address` | The address for which the borrow position is repaid |      |
| amount     | uint256  | The amount getting repaid                           |      |

### permit

```solidity
function permit(    address owner,    address spender,    uint256 value,    uint256 deadline,    uint8 v,    bytes32 r,    bytes32 s) external override
```

Allows a user to permit another account (or contract) to use their funds using a signed message. This enables gas-less transactions and single approval/transfer transactions. Allow passing a signed message to approve spending.

Implements the permit function as for EIP-2612.

#### Code

```solidity
/// @inheritdoc IAToken
  function permit(
    address owner,
    address spender,
    uint256 value,
    uint256 deadline,
    uint8 v,
    bytes32 r,
    bytes32 s
  ) external override {
    require(owner != address(0), Errors.ZeroAddressNotValid());
    //solium-disable-next-line
    require(block.timestamp <= deadline, Errors.InvalidExpiration());
    uint256 currentValidNonce = _nonces[owner];
    bytes32 digest = keccak256(
      abi.encodePacked(
        '\x19\x01',
        DOMAIN_SEPARATOR(),
        keccak256(abi.encode(PERMIT_TYPEHASH, owner, spender, value, currentValidNonce, deadline))
      )
    );
    require(owner == ECDSA.recover(digest, v, r, s), Errors.InvalidSignature());
    _nonces[owner] = currentValidNonce + 1;
    _approve(owner, spender, value);
  }
```



#### Input Parameters:

| Name     | Type    | Description                                                  |      |
| -------- | ------- | ------------------------------------------------------------ | ---- |
| owner    | address | The owner of the funds                                       |      |
| spender  | address | The spender of the funds                                     |      |
| value    | uint256 | The amount the spender is permitted to spend                 |      |
| deadline | uint256 | The deadline timestamp, use type(uint256).max for max/no deadline |      |
| v        | uint8   | The V signature parameter                                    |      |
| r        | bytes32 | The R signature parameter                                    |      |
| s        | bytes32 | The S signature parameter                                    |      |

Example of signing and utilizing permit:



```jsx
import { signTypedData_v4 } from "eth-sig-util";import { fromRpcSig } from "ethereumjs-util";// ... other importsimport aTokenAbi from "./aTokenAbi.json";// ... setup your web3 providerconst aTokenAddress = "ATOKEN_ADDRESS";const aTokenContract = new web3.eth.Contract(aTokenAbi, aTokenAddress);const privateKey = "YOUR_PRIVATE_KEY_WITHOUT_0x";const chainId = 1;const owner = "OWNER_ADDRESS";const spender = "SPENDER_ADDRESS";const value = 100; // Amount the spender is permittedconst nonce = 1; // The next valid nonce, use `_nonces()`const deadline = 1600093162;const permitParams = {  types: {    EIP712Domain: [      { name: "name", type: "string" },      { name: "version", type: "string" },      { name: "chainId", type: "uint256" },      { name: "verifyingContract", type: "address" },    ],    Permit: [      { name: "owner", type: "address" },      { name: "spender", type: "address" },      { name: "value", type: "uint256" },      { name: "nonce", type: "uint256" },      { name: "deadline", type: "uint256" },    ],  },  primaryType: "Permit",  domain: {    name: "aTOKEN_NAME",    version: "1",    chainId: chainId,    verifyingContract: aTokenAddress,  },  message: {    owner,    spender,    value,    nonce,    deadline,  },};const signature = signTypedData_v4(Buffer.from(privateKey, "hex"), {  data: permitParams,});// The signature can now be used to execute the transactionconst { v, r, s } = fromRpcSig(signature);await aTokenContract.methods  .permit({    owner,    spender,    value,    deadline,    v,    r,    s,  })  .send()  .catch((e) => {    throw Error(`Error permitting: ${e.message}`);  });
```

### rescueTokens

```solidity
function rescueTokens(    address token,    address to,    uint256 amount) external override onlyPoolAdmin
```

Rescue and transfer tokens locked in this contract. Only callable by [POOL_ADMIN](https://aave.com/docs/developers/smart-contracts/acl-manager#roles-pool-admin).

#### Code

```solidity
/// @inheritdoc IAToken
 function rescueTokens(address token, address to, uint256 amount) external override onlyPoolAdmin {
    require(token != _underlyingAsset, Errors.UnderlyingCannotBeRescued());
    IERC20(token).safeTransfer(to, amount);
  }
```

#### Input Parameters:

| Name   | Type    | Description                     |      |
| ------ | ------- | ------------------------------- | ---- |
| token  | address | The address of the token        |      |
| to     | address | The address of the recipient    |      |
| amount | uint256 | The amount of token to transfer |      |

## View Methods

### balanceOf

```solidity
function balanceOf(address user)    public    view    virtual    override(IncentivizedERC20, IERC20)    returns (uint256)
```

Returns the amount of tokens owned by user.

Overrides the base function.

#### Code

```solidity
 /// @inheritdoc IERC20
 function balanceOf(
    address user
  ) public view virtual override(IncentivizedERC20, IERC20) returns (uint256) {
    return
      super.balanceOf(user).getATokenBalance(POOL.getReserveNormalizedIncome(_underlyingAsset));
  }
```



#### Input Parameters:

| Name | Type    | Description             |      |
| ---- | ------- | ----------------------- | ---- |
| user | address | The address of the user |      |

#### Return Values:

| Type    | Description                        |      |
| ------- | ---------------------------------- | ---- |
| uint256 | The amount of tokens owned by user |      |

### totalSupply

```solidity
function totalSupply() public view virtual override(IncentivizedERC20, IERC20 returns (uint256)
```

Returns the amount of tokens in existence.

Overrides the base function.

#### Code

```solidity
  /// @inheritdoc IERC20
  function totalSupply() public view virtual override(IncentivizedERC20, IERC20) returns (uint256) {
    return super.totalSupply().getATokenBalance(POOL.getReserveNormalizedIncome(_underlyingAsset));
  }
```

#### Return Values:

| Type    | Description                       |      |
| ------- | --------------------------------- | ---- |
| uint256 | The amount of tokens in existence |      |

### RESERVE_TREASURY_ADDRESS

```solidity
function RESERVE_TREASURY_ADDRESS() external view override returns (address)
```

Returns the address of the Aave treasury, controlled by governance, receiving the fees on this aToken.

#### Return Values:



| Type    | Description                      |      |
| ------- | -------------------------------- | ---- |
| address | The address of the Aave treasury |      |

### UNDERLYING_ASSET_ADDRESS

```solidity
function UNDERLYING_ASSET_ADDRESS() external view override returns (address)
```

Returns the address of the underlying reserve asset of this aToken (E.g. WETH for aWETH).

#### Return Values:

| Type    | Description                         |      |
| ------- | ----------------------------------- | ---- |
| address | The address of the underlying asset |      |

### DOMAIN_SEPARATOR

```solidity
function DOMAIN_SEPARATOR() public view override(IAToken, EIP712Base) returns (bytes32)
```

Get the domain separator for the token at the current chain.

Return cached value if chainId matches cache, otherwise recomputes separator.

Overrides the base function to fully implement IAToken.

#### Return Values:



| Type    | Description                                        |      |
| ------- | -------------------------------------------------- | ---- |
| bytes32 | The domain separator of the token at current chain |      |

### nonces

```solidity
function nonces(address owner) public view override(IAToken, EIP712Base) returns (uint256)
```

Returns the nonce value for address specified as parameter. This is the nonce used when calling permit().

Overrides the base function to fully implement IAToken.

### Code

```solidity
  function nonces(address owner) public view override(IAToken, EIP712Base) returns (uint256) {
    return super.nonces(owner);
  }
```

#### Input Parameters:

| Name  | Type    | Description              |      |
| ----- | ------- | ------------------------ | ---- |
| owner | address | The address of the owner |      |

#### Return Values:



| Type    | Description            |      |
| ------- | ---------------------- | ---- |
| uint256 | The nonce of the owner |      |

Example:



```jsx
const token = new Contract(aTokenAddress, aToken.abi, provider);await token.nonces(user);
```

## Pure Methods

### getRevision

```solidity
function getRevision() internal pure virtual override returns (uint256)
```

Returns the revision number of the contract. Needs to be defined in the inherited class as a constant.

Returns 0x1.

#### Return Values:

| Type    | Description         |      |
| ------- | ------------------- | ---- |
| uint256 | The revision number |      |



# Reference

https://aave.com/docs/developers/smart-contracts/tokenization